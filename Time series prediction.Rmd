---
title: "Data Exploration"
author: "Gianluca Scuri"
date: "2022-12-11"
output: html_document
---

# Time series forecast

## Setup and loading dataset

```{r}
set.seed(100)

Sys.setenv(TZ='GMT') # imposto la time zone

packages <- c("forecast", "KFAS", "xts", "fastDummies", "tsfknn") # librerie

installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```

```{r}
stats <- function(actual,pred){
  rmse <- sqrt(mean((actual - pred)^2))
  mape <- mean(abs((actual - pred)/actual))*100
  mae <- mean(abs(actual - pred))
  cat("RMSE", rmse, "\nMAPE", mape, "\nMAE ", mae)
  #return(c(rmse, mape, mae))
}

# Significativitá regressori
pars_test <- function(coef, var_coef){
  test <- (1-pnorm(abs(coef)/sqrt(diag(var_coef))))*2
  return(test)
}
```

Funzione per plottare le predizioni

```{r}
plot_pred <- function(pred, days=3){
  diff <- plot(data_xts[(val_index-144*5):(val_index+144*npred-1)]-pred) # serie storica - storica
  plot <- plot(data_xts[(val_index-144*5):(val_index+144*npred-1)], lwd=3) # serie storica e storica
  plot <- lines(pred, type = "l", col = "red", lwd=3)
  zoom <- plot(data_xts[(val_index+144*(npred-days)):(val_index+144*npred-1)], lwd=3) # zoom serie storica e storica
  zoom <- lines(pred, type = "l", col = "red", lwd=3)
  c(diff, plot, zoom)
}
```

```{r}
working_dir = dirname(rstudioapi::getSourceEditorContext()$path)
setwd(working_dir)

data <- read.csv("data2022_train.csv", colClasses=c("character", "numeric"))
```

### Trasformazione in serie storica XTS

```{r}
data_xts <- xts(data$y, as.POSIXct(data$X, format="%Y-%m-%d %H:%M:%S", tz="GMT"))
```

```{r}
periodicity(data_xts)
```

## Data Exploration

```{r}
summary(data_xts)
```

```{r}
tsdisplay(train)
```

```{r}
plot(data_xts)
```

```{r}
plot(aggregate(data_xts, month, mean))
```

```{r}
plot(data_xts[seq(1, nrow(data), 144)])
plot(data_xts[1:144])
plot(data_xts[1:144*21])
```

```{r}
autoplot(mstl(data_xts))
```

### Dipendenza in varianza

```{r}
med <- tapply(data_xts, rep(1:334, each = 144), mean)
sds <- tapply(data_xts, rep(1:334, each = 144), sd)
plot(med, sds)
```

Forse é meglio lavorare con i logaritmi

### Detecting outliers

```{r}
plot(diff(data_xts,1))
data_xts[diff(data_xts,1) < -5000 | diff(data_xts,1) > 5000] #|> index() |> as.Date()
```

```{r}
par(mfrow=c(2,2))
plot(data_xts["2017-01-14"])
#plot(train["2017-01-15"])
plot(data_xts["2017-03-28"])
plot(data_xts["2017-04-20"])
plot(data_xts["2017-05-31"])
```

### Train, validation e test set

```{r}
tseq <- seq(from = index(data_xts[nrow(data_xts),])+600, length.out = 144*30, by = 600)
data_xts_complete <- c(data_xts, xts(rep(as.numeric(NA), length(tseq)), tseq))
cat(paste0("from: ", index(data_xts_complete[1]), "\nto:   ", index(data_xts_complete[nrow(data_xts_complete)])))
```

```{r}
npred <- 30 # numero di giorni da predire
small_date <- "2017-10-01 00:00:00"
small_index <- which(index(data_xts_complete) == small_date)
val_date <- "2017-11-01 00:00:00"
val_index <- which(index(data_xts_complete) == val_date)
test_date <- "2017-12-01 00:00:00"
test_index <- which(index(data_xts_complete) == test_date)
cat(paste0("small_index: ", small_index,"\nval_index:   ", val_index, "\ntest_index:  ", test_index))
```

```{r}
train <- data_xts_complete[1:(val_index-1)]
small <- data_xts_complete[small_index:(val_index-1)] # train piu veloce
val <- data_xts_complete[val_index:(val_index+144*npred-1),]
test <- data_xts_complete[test_index:nrow(data_xts_complete)]
cat(paste0("small: ", nrow(small), "\ntrain: ", nrow(train), "\nval:   ", nrow(val), "\ntest:  ", nrow(test)))
```

## Data Modeling

### ARIMA Models

-   Possibilita 1

    -   modellare settimana con dummy

    -   modellare giorno con differenza stagionale

-   Possibilita 2

    -   144 modelli per togliere stagionalita giornaliera

```{r}
train_dummy <- fastDummies::dummy_cols(format(index(train), "%u"), remove_selected_columns = TRUE, remove_first_dummy = TRUE)
rownames(train_dummy) <- index(train)
colnames(train_dummy) <- c("mart", "merc", "giov", "ven", "sab", "dom")
train_dummy <- as.matrix(train_dummy)

val_dummy <- fastDummies::dummy_cols(format(index(val), "%u"), remove_selected_columns = TRUE, remove_first_dummy = TRUE)
rownames(val_dummy) <- index(val)
colnames(val_dummy) <- c("mart", "merc", "giov", "ven", "sab", "dom")
val_dummy <- as.matrix(val_dummy)

#train_arima <- cbind(train, train_dummy)
```

Stimo i parametri (p, q, d)

```{r}
ndiffs(train)
```

```{r}
train |> Acf(300)
train |> #[42000:length(train)]
  #diff() |>
  diff() |>
  #diff(144*7) |>
  #diff(144) |>
  #autoplot()
  Acf(300)
#train[diff(diff(train, 144), 1) < -4000]
```

```{r}
train |> Pacf(300)
train |>
  #diff(144) |>
  diff() |>
  Pacf(300)
```

```{r}
nsdiffs(train)
```

#### Mod 1

```{r}
mod1 <- Arima(y = ts(train[(length(train)-144*14):length(train)]), # subset del train
              order = c(0, 1, 1),
              list(order = c(0, 1, 1), period = 144), # gli specifichiamo la frequenza
              #xreg = dummy_week,
              include.constant = TRUE)
summary(mod1)
```

```{r}
#mod1.plot_diagnostics(figsize=c(7,5))
#plt.show()
```

```{r}
# plot(index(mod1$residuals)/600/144, mod1$residuals, type='l', xlab='Day', ylab='Residual')
```

```{r}
pred <- forecast(mod1, 144*npred)
plot(pred)
#abline(v=val_index*600)
```

```{r}
pred <- xts(pred$mean, index(val))
```

```{r}
plot_pred(pred)
```

```{r}
stats(val, pred)
```

#### Mod 2

```{r}
mod2 <- Arima(y = ts(small[(length(small)-14*144):length(small)]), # subset del train
              order = c(0, 1, 1),
              list(order = c(0, 1, 1), period = 144), # gli specifichiamo la frequenza
              #xreg = dummy_week,
              include.constant = TRUE)
summary(mod2)
```

```{r}
pred2 <- forecast(mod2, 144*npred, xreg=val_dummy)
plot(pred2)
abline(v=val_index*600)
```

```{r}
pred2 <- xts(pred2$mean, index(val))
```

```{r}
plot_pred(pred2)
```

```{r}
stats(val, pred2)
```

#### Mod 3

```{r}
mod3 <- auto.arima(ts(small, frequency = 144),
                   stepwise = TRUE,
                   approximation = TRUE,
                   xreg = dummy_week[small_index:nrow(dummy_week),]) # Minimizza AIC
mod3
```

```{r}
mod3 <- Arima(y = ts(small[(length(small)-14*144):length(small)]), # subset del train
              order = c(2, 1, 0),
              list(order = c(0, 1, 1), period = 144), # gli specifichiamo la frequenza
              #xreg = dummy_week,
              include.constant = TRUE)
mod3
```

ARIMA(2,1,0)(0,1,0)[144]

```{r}
pred3 <- forecast(mod3,
                  144*npred)
                  #xreg = val_dummy)
plot(pred3)
abline(v=val_index*600)
```

```{r}
pred3 <- xts(pred3$mean, index(val))
plot_pred(pred3)
```

```{r}
o <- Arima(ts(small, frequency = 144),
           order = c(1, 0, 0),
           seasonal = list(order = c(0, 1, 2)))
pred3 <- forecast(o, h = 144*npred)
```

```{r}
pred3 <- xts(pred3$mean, index(val))
plot_pred(pred3)
```

### UCM Models

Definisco il train set per i modelli ucm e una versione ridotta per velocizzare il train

```{r}
tseq <- seq(from = index(train[nrow(train),])+600,length.out = 144*npred,by = 600) # creo sequenza di NA a step di 10 min
train_ucm <- c(train, xts(rep(as.numeric(NA), length(tseq)), tseq)) # aggiungo NA a train
small_ucm <- c(small, xts(rep(as.numeric(NA), length(tseq)), tseq)) # aggiungo NA a small
```

#### Mod 1

```{r}
ucm_pre <- function(train) {
  # Definizione del modello
  mod <- SSModel(V1~SSMtrend(2, list(NA, NA))+
                    SSMseasonal(144, NA, "trigonometric", harmonics = 1:2)+
                    SSMseasonal(1008, NA, "trigonometric", harmonics = 1),
                  H=NA, 
                  data=train)

  # Assegna i valori iniziali ai parametri, parte da 0.
  mod$P1inf[] <- 0 # no componenti diffuse
  mod$a1[1] <- mean(log(train[1:144])) # scelta basata sui valori del primo mese
  
  vy <- var(log(train[1:144])) # varianza serie storica (utilizzata sotto per dare un ordine di grandezza)
  diag(mod$P1) <- vy*10 # specifichiamo che abbiamo molta incertezza sui valori che abbiamo specificato
  
  #Inizializzazione delle varianze sulla base di vy
  pars <- log(c(
    logVarEta = vy/100000,
    logVarZeta = vy/150,
    logVarOm144 = vy,
    logVarOm1008 = vy/100,
    logVarEps = vy/10
  ))
  
  # funzione di update
  updt <- function(pars, model){
    model$Q[1,1,1] <- exp(pars[1])
    model$Q[2,2,1] <- exp(pars[2])
    diag(model$Q[3:6, 3:6, 1]) <- exp(pars[3])
    diag(model$Q[7:8, 7:8, 1]) <- exp(pars[4])
    model$H[1,1,1] <- exp(pars[5])
    model
  }
  
  # Train - Si allena sui valori passati (quindi quei valori di train non nulli)
  fit <- fitSSM(mod, pars, updt)
  fit$optim.out
  
  # Filtro di karman - Effetua le predizioni - kfs1$muhat contiene una serie storica predetta (anche i dati di train vengono predetti)
  kfs <- KFS(fit$model,
            smoothing = c("state", "signal", "disturbance"))
  
  # conversione muhat in serie storica
  muhat <- xts(as.matrix(kfs$muhat),
                index(train))
  muhat <- as.xts(muhat)
  return(muhat)
}
```

```{r}
pred <- ucm_pre(train_ucm)
```

```{r}
plot_pred(pred)
```

```{r}
stats(data_xts[val_index:(val_index+144*npred-1)], pred[(nrow(pred)-144*npred+1):nrow(pred)])
```

#### Mod 2

```{r}
ucm_pre <- function(train) {
  arm144 <- 10
  arm1008 <- 1
  # Definizione del modello
  mod <- SSModel(V1~SSMtrend(2, list(NA, NA))+
                    SSMseasonal(144, NA, "trigonometric", harmonics = 1:arm144)+
                    SSMseasonal(1008, NA, "trigonometric", harmonics = 1:arm1008),
                  H=NA, 
                  data=train)

  # Assegna i valori iniziali ai parametri, parte da 0.
  mod$P1inf[] <- 0 # no componenti diffuse
  mod$a1[1] <- mean(train[1:144]) # expected value of the initial state vector α[1]
  
  vy <- var(train[1:144]) # varianza serie storica (utilizzata sotto per dare un ordine di grandezza)
  diag(mod$P1) <- vy*10 # specifichiamo che abbiamo molta incertezza sui valori che abbiamo specificato
  
  #Inizializzazione delle varianze sulla base di vy
  pars <- log(c(
    logVarEta = vy/10000,
    logVarZeta = vy/100000,
    logVarOm144 = vy/1000,
    logVarOm1008 = vy/100000,
    logVarEps = vy/1000
  ))
  
  # funzione di update
  updt <- function(pars, model){
    model$Q[1,1,1] <- exp(pars[1])
    model$Q[2,2,1] <- exp(pars[2])
    diag(model$Q[3:(2+arm144*2), 3:(2+arm144*2), 1]) <- exp(pars[3])
    diag(model$Q[(3+arm144*2):(2+arm144*2+arm1008*2), (3+arm144*2):(2+arm144*2+arm1008*2), 1]) <- exp(pars[4])
    model$H[1,1,1] <- exp(pars[5])
    model
  }
  
  # Train - Si allena sui valori passati (quindi quei valori di train non nulli)
  fit <- fitSSM(mod, pars, updt)
  print(fit$optim.out)
  
  # Filtro di karman - Effetua le predizioni - kfs1$muhat contiene una serie storica predetta (anche i dati di train vengono predetti)
  kfs <- KFS(fit$model,
            smoothing = c("state", "signal", "disturbance"))
  
  # conversione muhat in serie storica
  muhat <- xts(as.matrix(kfs$muhat),
                index(train))
  muhat <- as.xts(muhat)
  return(muhat)
}
```

```{r}
pred <- ucm_pre(train_ucm)
```

```{r}
plot_pred(pred)
```

```{r}
stats(data_xts[val_index:(val_index+144*npred-1)], pred[(nrow(pred)-144*npred+1):nrow(pred)])
```

Minimo

    RMSE 1718.399 
    MAPE 4.814626 
    MAE  1366.986

#### Mod 3

```{r}
ucm_pre <- function(train) {
  arm144 <- 10
  arm1008 <- 1
  # Definizione del modello
  mod <- SSModel(V1~SSMtrend(2, list(NA, NA))+
                    SSMseasonal(144, NA, "trigonometric", harmonics = 1:arm144)+
                    SSMseasonal(1008, NA, "trigonometric", harmonics = 1:arm1008),
                  H=NA, # Covariance matrix or array of disturbance terms ε[t] of observation equation
                  data=train)
  
  mod$P1inf[] <- 0 # diffuse part of P[1] (p[1] is the covariance matrix of α[1])
  mod$a1[1] <- mean(train[1:(144*3)]) # valore del livello iniziale (basata sulla media dei primi 3 giorni)
  vy <- var(log(train[1:(144)])) # varianza serie storica ((utilizzata sotto per dare un ordine di grandezza))primo giorno)
  diag(mod$P1) <- vy * 10 # specifichiamo che abbiamo molta incertezza sui valori che abbiamo specificato
  
  # definisco le varianze a partire da vy
  pars <- log(c(
    logVarEta = vy/100000,
    logVarZeta = vy/1500,
    logVarOm144 = vy/1,
    logVarOm1008 = vy/10000,
    logVarEps = vy/100
  ))
  
  # funzione di update -> imposto i valori iniziali
  updt <- function(pars, model){
    m <- arm144*2
    n <- arm1008*2
    model$Q[1,1,1] <- exp(pars[1])
    model$Q[2,2,1] <- exp(pars[2])
    diag(model$Q[3:(2+m), 3:(2+m), 1]) <- exp(pars[3])
    diag(model$Q[(3+m):(2+m+n), (3+m):(2+m+n), 1]) <- exp(pars[4])
    model$H[1,1,1] <- exp(pars[5])
    model
  }
  
  # Train - Si allena sui valori passati (quindi quei valori di train non nulli)
  fit <- fitSSM(mod, pars, updt)
  print(fit$optim.out)
  
  # Filtro di karman - Effetua le predizioni - kfs1$muhat contiene una serie storica predetta (anche i dati di train vengono predetti)
  kfs <- KFS(fit$model,
            smoothing = c("state", "signal", "disturbance"))
  
  # conversione muhat in serie storica
  muhat <- xts(as.matrix(kfs$muhat),
                index(train))
  muhat <- as.xts(muhat)
  return(muhat)
}
```

```{r}
pred <- ucm_pre(small_ucm) # fare predizioni su 
```

```{r}
plot_pred(pred)
```

```{r}
stats(data_xts[val_index:(val_index+144*npred-1)], pred[(nrow(pred)-144*npred+1):nrow(pred)])
```

### Machine Learning

La serie é abbastanza regolare quindi (a meno di eventi imprevedibili) le predizioni molto probabilemtne ircadono nel range dei valori passati e ne ricalcano i trend

#### Mod 1

```{r}
kn <- knn_forecasting(ts(train),
                      h = 144*npred,
                      lags = 1:(144*7),
                      #k = 2,
                      msas = "MIMO",# cf = "median",
                      transform = "multiplicative")
#kn
```

```{r}
knn <- xts(kn$prediction, index(val))
plot_pred(knn)
```

```{r}
stats(val, knn)
```

#### Mod 2

```{r}
kn <- knn_forecasting(ts(train),
                      h = 144*npred,
                      lags = 1:(144),
                      #k = 2,
                      msas = "MIMO",# cf = "median",
                      transform = "multiplicative")
```

```{r}
knn <- xts(kn$prediction, index(val))
plot_pred(knn)
```

```{r}
stats(val, knn)
```

## Data prediction

```{r}
train_gen_nov <- data_xts_complete[1:(val_index+144*npred-1),]
```

```{r}
dic_arima <- forecast(Arima(),
                      h = 144*npred)
```

```{r}
dic_ucm <- forecast(ucm(),
                    h = 144*npred)
```

```{r}
dic_ml <- knn_forecasting(ts(train_gen_nov),
                      h = 144*npred,
                      lags = 1:(144*7),
                      k = 2,
                      msas = "MIMO", cf = "median",
                      transform = "multiplicative")
dic_ml_pred <- xts(dic_ml$prediction, index(test))
```

```{r}
results <- data.frame(arima = dic_arima_pred,
                      ucm = dic_ucm_pred,
                      ml = dic_ml_pred)
rownames(results) <- index(test)
```

```{r}
write.csv(results, "886725_20221224.csv", row.names=TRUE) # cambiare data e verificare row.names
```
